我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。排序算法大体可分为两种：
一种是比较排序，时间复杂度$O(nlogn)$ ~ $O(n^2)$，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。
另一种是非比较排序，时间复杂度可以达到$O(n)$，主要有：计数排序，基数排序，桶排序等。
#算法性能
|排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性|
|:-:|:-:|:-:|:-:|:-:|:-:|
|冒泡排序|$O(n^{2})$|$O(n)$|$O(n^{2})$|$O(1)$|稳定|
|简单选择排序|$O(n^{2})$|$O(n^{2})$|$O(n^{2})$|$O(1)$|不稳定|
|直接插入排序|$O(n^{2})$|$O(n)$|$O(n^{2})$|$O(1)$|稳定|
|希尔排序|$O(nlogn)$~$O(n^{2})$|$O(n^{1.3})$|$O(n^{2})$|$O(1)$|不稳定|
|堆排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(1)$|不稳定|
|归并排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(n)$|稳定|
|快速排序|$O(nlogn)$|$O(nlogn)$|$O(n^{2})$|$O(logn)$~$O(n)$|不稳定|
## 排序算法稳定性
排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。
#### 作用
排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。

## 冒泡排序 *Bubble Sort*
#### 算法原理
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
####图示
![avatar](https://images2015.cnblogs.com/blog/739525/201603/739525-20160329100034660-1420925220.gif)
####实现
```
// 分类 -------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定
void BubbleSort(int *array, int size)
{
        for(int i=0; i<size-1; i++){
                for(int j=0; j<size-1-i; j++){
                        if(array[j] > array[j+1]){//重的往下沉，故每次只需循环到size-1-i
                                array[j] ^= array[j+1];
                                array[j+1] ^= array[j];
                                array[j] ^= array[j+1];
                        }
                }
        }
}
```
## 鸡尾酒排序 *Cocktail sort*
鸡尾酒排序也就是定向冒泡排序, 鸡尾酒搅拌排序, 搅拌排序 (也可以视作选择排序的一种变形), 涟漪排序, 来回排序 or 快乐小时排序, 是冒泡排序的一种变形。此演算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。
#### 算法原理
数组中的数字本是无规律的排放，先找到最小的数字，把他放到第一位，然后找到最大的数字放到最后一位。然后再找到第二小的数字放到第二位，再找到第二大的数字放到倒数第二位。以此类推，直到完成排序。
#### 图示
![avatar](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=cbb942209c16fdfacc61cebcd5e6e731/79f0f736afc3793166033f22eac4b74543a91155.jpg)
#### 实现
```
// 分类 -------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定
void CocktailSort(int *array, int size)
{
        int left = 0, right = size - 1;
        while(left < right){
                for(int i=left; i<right; i++){ //重的往下沉
                        if(array[i] > array[i+1]){
                                array[i] ^= array[i+1];
                                array[i+1] ^= array[i];
                                array[i] ^= array[i+1];
                        }
                
                }
                right--; //上边界减一
                for(int i=right; i>left; i--){
                        if(array[i] < array[i-1]){ //轻的往上浮
                                array[i] ^= array[i-1];
                                array[i-1] ^= array[i];
                                array[i] ^= array[i-1];
                        }
                }
                left++;//下边界加一
        }
}
```

## 插入排序 *Insertion Sort*
基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。
#### 算法原理
将n个元素的数列分为已有序和无序两个部分，如下所示：
{{a1}，{a2，a3，a4，…，an}}
{{a1⑴，a2⑴}，{a3⑴，a4⑴ …，an⑴}}
…
{{a1(n-1），a2(n-1) ，…},{an(n-1)}}
每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较，找出插入位置，将该元素插入到有序数列的合适位置中。
过程图示：
![avatar](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=198f4585a7efce1bee2bcfc89f50f3e8/d0c8a786c9177f3eee69fa7e70cf3bc79f3d5667.jpg)
#### 实现
```
// 分类 ------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定
void InsertionSort(int *array, int size)
{
        int i, j, key;
        for(i=1; i<size; i++){
                key = array[i]; //取出待排序的数值
                for(j=i; j>0&&array[j-1]>key; j--) //只要当前值大于待排序数值,往前找，直到索引为0
                        array[j] = array[j-1];          
                array[j] = key;
        }
}
```
### 二分插入排序
二分法插入排序是基于插入排序算法，只是在查找插入位置时用了二分法查找。
当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。
#### 实现
```
// 分类 -------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- O(nlogn)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定
void dichotomy(int *array, int size)
{
        int left, right, mid, key;
        for(int i=1; i<size; i++){
                key = array[i];
                left = 0;
                right = i-1;
                while(left <= right){
                        mid = (left + right) / 2;
                        if(array[mid] > key)
                                right = mid - 1;
                        else
                                left = mid + 1;
                }
                for(int j=i; j>left; j--)
                        array[j] = array[j-1]

                array[left] = key;
}
```

## 希尔排序
希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法。
#### 图示
![avatar](https://images2015.cnblogs.com/blog/739525/201603/739525-20160328205313363-2043878119.gif)
#### 实现
```
// 分类 -------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)
// 最优时间复杂度 ---- O(n)
// 平均时间复杂度 ---- 根据步长序列的不同而不同。
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 不稳定
void ShellSort(int *array, int size)
{
        int key;
        for(h=size/2;h>0; h/=2){ //增量控制
                for(int i=h; i<n; i++){ //这里就是插入排序
                        key = array[j];
                        for(int j=i-h; k>0&&array[j]>key; j-=h)
                                array[j+h] = array[j];
                        array[j+h] = key;
                }
        }
}
```
## 选择排序 *Selection Sort*
选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。
#### 过程示图
![avatar](https://images2015.cnblogs.com/blog/739525/201603/739525-20160329102006082-273282321.gif) 
#### 实现
```
// 分类 -------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- O(n^2)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 不稳定
void SelectionSort(int *array, int size)
{
        int min;
        for(int i=0; i<size-1; i++){
                min = i;
                for(int j=i+1; j<size-1; j++)
                        if(array[j] <array[min])
                                min = j;

                if(min != i){
                        array[min] ^= array[i];
                        array[i] ^= array[min];
                        array[min] ^= array[i];
                }
        }
}
```
## 并归排序
归并排序是创建在归并操作上的一种有效的排序算法，效率为$O(nlogn)$，1945年由冯·诺伊曼首次提出。
#### 原理
　　归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。
#### 过程
　　归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾
#### 图示
![avatar](https://images2015.cnblogs.com/blog/739525/201603/739525-20160328211743473-909317024.gif)
#### 实现
```
// 分类 -------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- O(nlogn)
// 最优时间复杂度 ---- O(nlogn)
// 平均时间复杂度 ---- O(nlogn)
// 所需辅助空间 ------ O(n)
// 稳定性 ------------ 稳定

/*----------------------递归实现------------------------*/
//合并
void Merge(int *array, int left, int mid, int right)
{
        int len = right - left + 1;
        int *a = (int*)malloc(sizeof(int) * len);
        int index = 0, i =left, j = mid + 1;
        // 对于数组array,array[left...mid], array[mid+1...right]都是有序的
        while(i<= mid && j <= right)
                a[index++] = array[i] < array[j] ?
                                array[i++] : array[j++];

        while(i <= mid)
                a[index++] = array[i++];
        while(j <= right)
                a[index++] = array[j++];

        for(int k=0; k<len; k++)
                array[left++] = a[k];
        free(a);
}
// 递归
void MergeSort(int *array, int left, int right)
{
        if(left >= right)
                return;
        int mid = (left + right) / 2;
        MergeSort(array, left, mid);    //递归前半部分，合并并排序
        MergeSort(array, mid+1, right); //递归后半部分，合并并排序
        Merge(array, left, mid, right); //合并前后序列
}
```

## 堆排序
堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] >= A[i]。小根堆要求每个节点不小于其父节点的值，即A[PARENT[i]] <= A[i]。大根堆用于排序，小根堆用于优先队列。

#### 过程
1. 由输入的无序数组构造一个最大堆，作为初始的无序区
2. 把堆顶元素（最大值）和堆尾元素互换
3. 把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整
4. 重复步骤2，直到堆的尺寸为1

