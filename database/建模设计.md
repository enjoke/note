## 建模简介
## 建模
在设计数据库时，对现实世界进行分析、抽象、并从中找出内在联系，进而确定数据库的结构，这一过程就称为数据库建模。它主要包括两部分内容：确定最基本的数据结构；对约束建模。
1. 概念模型的表示方法
E-R图主要是由实体、属性和联系三个要素构成的。
2. 确定系统实体、属性及联系
系统分析阶段建立数据字典和数据流程图->建立概念模型->逻辑模型->物理模型；利用系统分析阶段建立的数据字典，并对照数据流程图对系统中的各个数据项进行分类、组织，确定系统中的实体、实体的属性、标识实体的码以及实体之间联系的类型。
在数据字典中“数据项”是基本数据单位，一般可以作为实体的属性。“数据结构”、“数据存储”和“数据流”条目都可以作为实体，因为它们总是包含了若干的数据项。作为属性必须是不可再分的数据项，也就是说在属性中不能包含其他的属性。
3. 确定局部（分）E-R图
根据上面的分析，可以画出部分实体－联系图。
在这些实体中有下画线的属性可以作为实体的码，这几个实体之间存在着1：1、l：n和m：n几种联系。
4. 集成完整（总）E-R图
各个局部（分）E-R图画好以后，应当将它们合并起来集成为完整（总）E-R图。在集成时应当注意如下几点：
    - 消除不必要的冗余实体、属性和联系。
    - 解决各分E-R图之间的冲突。
    - 根据情况修改或重构E-R图。

## 三范式
**范式 *Normal Form* **
**符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度**
它是英国人 E.F.Codd（埃德加·弗兰克·科德）在上个世纪70年代提出关系数据库模型后总结出来的，范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。目前有迹可寻的共有8种范式，依次是：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。通常所用到的只是前三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）
一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式。
### 第一范式*1NF*
**属性原子性约束**, 属性是原子性的，即不可在拆分。
>>考虑这样一张表：【联系人】（姓名，性别，电话） 。
>>如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）
### 第二范式*2NF*
**主键约束**
一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
>>考虑一个订单明细表：【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。
因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是（OrderID，ProductID）。显而易见 Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice（单价），ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。
可以把【OrderDetail】表拆分为【OrderDetail】（OrderID，ProductID，Discount，Quantity）和【Product】（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。
###第三范式*3NF*
**冗余性约束**
任何字段不能由其他字段派生出来。要求字段没有冗余。
>>考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。
其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，多个订单中有同一个用户下单，就会产生数据冗余； 3NF中说的传递依赖，就出现了，所以不符合 3NF。
通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。
### 优缺点
优点
- 减少冗余
- 减少异常（delete，update，insert）
- 让数据组织的更加和谐

缺点：
范式等级与复杂度是递进的；通过范式的不断升级，我们会发现应用的范式等级越高，则表越多。表多会带来很多问题：
- 查询时要连接多个表，增加了查询的复杂度
- 查询时需要连接多个表，降低了数据库查询性能
- 而现在的情况，磁盘空间成本基本可以忽略不计，所以数据冗余所造成的问题也并不是应用数据库范式的理由。

### 反范式设计*denormalization*
增加冗余而提高性能，这便是denormalization的意义。
#### 反范式场景
- 数据库水平拆分时，要通过数据冗余的方式减少join操作。
- 数据库垂直拆分时，同样三范式也满足不了需求。
- 应用程序解耦时，需要数据库层进行分离。
- 分布式数据库场景中，如何汇总数据。

